// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: state.sql

package db

import (
	"context"
)

const getBlockProcessingState = `-- name: GetBlockProcessingState :one
SELECT pool_address, last_processed_block, is_backfill, created_at, updated_at FROM block_processing_state
WHERE pool_address = $1 AND is_backfill = $2
`

type GetBlockProcessingStateParams struct {
	PoolAddress string `json:"poolAddress"`
	IsBackfill  bool   `json:"isBackfill"`
}

func (q *Queries) GetBlockProcessingState(ctx context.Context, arg GetBlockProcessingStateParams) (BlockProcessingState, error) {
	row := q.db.QueryRow(ctx, getBlockProcessingState, arg.PoolAddress, arg.IsBackfill)
	var i BlockProcessingState
	err := row.Scan(
		&i.PoolAddress,
		&i.LastProcessedBlock,
		&i.IsBackfill,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertBlockProcessingState = `-- name: UpsertBlockProcessingState :exec
INSERT INTO block_processing_state (
    pool_address,
    last_processed_block,
    is_backfill
) VALUES (
    $1, $2, $3
)
ON CONFLICT (pool_address, is_backfill) DO UPDATE
SET 
    last_processed_block = EXCLUDED.last_processed_block,
    updated_at = NOW()
`

type UpsertBlockProcessingStateParams struct {
	PoolAddress        string `json:"poolAddress"`
	LastProcessedBlock int64  `json:"lastProcessedBlock"`
	IsBackfill         bool   `json:"isBackfill"`
}

func (q *Queries) UpsertBlockProcessingState(ctx context.Context, arg UpsertBlockProcessingStateParams) error {
	_, err := q.db.Exec(ctx, upsertBlockProcessingState, arg.PoolAddress, arg.LastProcessedBlock, arg.IsBackfill)
	return err
}
